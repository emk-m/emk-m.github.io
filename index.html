<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Edge Line Displacement — p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(20,20,20,0.85);
      padding: 10px;
      border-radius: 8px;
      z-index: 20;
    }
    input[type="range"], select { width: 200px; margin-bottom: 6px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Upload Video</label><br>
    <input id="fileInput" type="file" accept="video/*"><br><br>

    <label>Edge Threshold</label><br>
    <input id="edgeThresh" type="range" min="10" max="255" value="50"><br>

    <label>Search Radius</label><br>
    <input id="searchRadius" type="range" min="1" max="8" value="3"><br>

    <label>Vector Scale</label><br>
    <input id="vecScale" type="range" min="1" max="12" value="5"><br>

    <label>Fade Amount</label><br>
    <input id="fadeAmount" type="range" min="0" max="255" value="50"><br>

    <label>Red Quadrant</label><br>
    <select id="redQuadrant">
      <option value="0">0–90°</option>
      <option value="1">91–180°</option>
      <option value="2">181–270°</option>
      <option value="3">271–360°</option>
    </select><br>

    <label>Display Mode</label><br>
    <select id="displayMode">
      <option value="lines">Lines</option>
      <option value="points">Points</option>
    </select><br>

    <label><input id="showVideo" type="checkbox" checked> Show Video</label>
  </div>

  <script>
    let video;
    let pg, prevEdges;
    let edgeThresh = 50;
    let searchRadius = 3;
    let vecScale = 5;
    let fadeAmount = 50;
    let redQuadrant = 0;
    let displayMode = "lines";
    let showVideo = true;
    let w = 160, h = 90; // downsample size

    function setup() {
      createCanvas(windowWidth, windowHeight);
      pixelDensity(1);
      pg = createGraphics(w, h);
      pg.pixelDensity(1);

      select('#fileInput').changed(handleFile);
      select('#edgeThresh').input(e => edgeThresh = +e.target.value);
      select('#searchRadius').input(e => searchRadius = +e.target.value);
      select('#vecScale').input(e => vecScale = +e.target.value);
      select('#fadeAmount').input(e => fadeAmount = +e.target.value);
      select('#redQuadrant').changed(e => redQuadrant = +e.target.value);
      select('#displayMode').changed(e => displayMode = e.target.value);
      select('#showVideo').changed(() => showVideo = select('#showVideo').checked());
    }

    function handleFile() {
      const f = select('#fileInput').elt.files[0];
      if (!f) return;
      if (video) video.remove();
      const url = URL.createObjectURL(f);
      video = createVideo(url, () => {
        video.hide();
        video.volume(0);
        video.loop();
      });
    }

    function sobelEdges(img) {
      img.loadPixels();
      const w = img.width, h = img.height;
      const edges = new Float32Array(w * h);
      const gray = new Float32Array(w * h);
      const d = img.pixels;
      for (let i = 0; i < w * h; i++) {
        const j = i * 4;
        gray[i] = 0.2126*d[j] + 0.7152*d[j+1] + 0.0722*d[j+2];
      }
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const gx = -gray[(y-1)*w + (x-1)] + gray[(y-1)*w + (x+1)]
                   - 2*gray[y*w + (x-1)] + 2*gray[y*w + (x+1)]
                   - gray[(y+1)*w + (x-1)] + gray[(y+1)*w + (x+1)];
          const gy = -gray[(y-1)*w + (x-1)] - 2*gray[(y-1)*w + x] - gray[(y-1)*w + (x+1)]
                   + gray[(y+1)*w + (x-1)] + 2*gray[(y+1)*w + x] + gray[(y+1)*w + (x+1)];
          edges[y*w + x] = Math.hypot(gx, gy);
        }
      }
      return edges;
    }

    function draw() {
      background(0, fadeAmount);

      if (!video) {
        fill(200);
        textAlign(CENTER, CENTER);
        text("Upload a video to detect edge displacement", width/2, height/2);
        return;
      }

      pg.image(video, 0, 0, w, h);
      const edges = sobelEdges(pg);

      const vw = video.elt.videoWidth || video.width || 640;
      const vh = video.elt.videoHeight || video.height || 360;
      const aspect = vw/vh;
      let drawW = width, drawH = width / aspect;
      if (drawH > height) {
        drawH = height;
        drawW = height * aspect;
      }
      const drawX = (width - drawW)/2;
      const drawY = (height - drawH)/2;
      const sx = drawW / w, sy = drawH / h;

      if (showVideo) image(video, drawX, drawY, drawW, drawH);

      if (prevEdges) {
        strokeWeight(2.5);
        for (let y = searchRadius; y < h - searchRadius; y += 2) {
          for (let x = searchRadius; x < w - searchRadius; x += 2) {
            const idx = y*w + x;
            if (edges[idx] > edgeThresh) {
              let bestDx = 0, bestDy = 0, bestDiff = Infinity;
              for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                  const j = (y+dy)*w + (x+dx);
                  if (j < 0 || j >= w*h) continue;
                  const diff = Math.abs(edges[idx] - prevEdges[j]);
                  if (diff < bestDiff && prevEdges[j] > edgeThresh) {
                    bestDiff = diff;
                    bestDx = dx;
                    bestDy = dy;
                  }
                }
              }

              if (bestDx !== 0 || bestDy !== 0) {
                const px = drawX + x * sx;
                const py = drawY + y * sy;
                const dx = bestDx * sx * vecScale;
                const dy = bestDy * sy * vecScale;

                const angle = (degrees(atan2(-dy, dx)) + 360) % 360;
                const quad = floor(angle / 90);
                if (quad === redQuadrant) stroke(255, 60, 60, 220);
                else stroke(200, 200, 200, 150);

                if (displayMode === "lines") {
                  line(px, py, px - dx, py - dy);
                } else {
                  point(px - dx, py - dy); // outer tip of line
                }
              }
            }
          }
        }
      }

      prevEdges = edges;
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>


